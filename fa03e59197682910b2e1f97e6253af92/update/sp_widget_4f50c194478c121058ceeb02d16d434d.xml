<?xml version="1.0" encoding="UTF-8"?><record_update table="sp_widget">
    <sp_widget action="INSERT_OR_UPDATE">
        <category>standard</category>
        <client_script><![CDATA[function spTicketConversation($scope, nowAttachmentHandler, $animate, $rootScope, cabrillo, $timeout, snRecordWatcher, spUtil, spAriaUtil, $http, $window, $sce, snAttachmentHandler, i18n, dynamicTranslation, dateUtils) {
    // KLF ADDITION
    // Flag that will expand the items on the timeline to fill te entire horizontal
    // space of the timeline as opposed to only taking up 50% of the space.
    // Flag is used in the html template to trigger CSS
    $scope.isKlfExpandedItems = $scope.options.is_klf_expanded_items === 'true';
    // END KLF ADDITION

    $scope.showLocationIcon = false;
    $scope.msg = "";
    $scope.isNative = cabrillo.isNative();
    $scope.errorMessages = [];
    var dateFormat = window.NOW.dateFormat;
    var hasTimeZone = g_user_date_time_format.indexOf('z') > -1;
    $scope.showDate = !hasTimeZone && (dateFormat.dateBoth || !dateFormat.timeAgo);
    $scope.showTimeAgo = hasTimeZone || dateFormat.dateBoth || dateFormat.timeAgo;
    var existingEntries = {};
    var c = this;
    var postLock = false; //global flag that tells the UI that it is okay to post a new message
    var skipNextRecordWatchUpdate = false;
    $scope.typing = [];
    $scope.embeddedInForm = false;
    $scope.$evalAsync(function() {
        if ($('#widget-form').find('.ticket-conversation-title').length) {
            $scope.embeddedInForm = true;
        }
    });
    if (!$scope.data.hasReadableJournalField && !$scope.data.isNewRecord)
        console.warn("No readable journal field (comments, work notes, etc.) available in the stream for this record");
    if ($scope.page && $scope.page.g_form)
        hideParentJournalFields();
    if ($scope.data.is_new_order) {
        $timeout(function() {
            spAriaUtil.sendLiveMessage($scope.data.requestSubmitMsg);
        }, 500);
    }

    function hideParentJournalFields() {
        if (!$scope.data.stream)
            return;

        var fields = $scope.data.stream.journal_fields;
        var g_form = $scope.page.g_form;
        for (var f in fields)
            g_form.setDisplay(fields[f].name, false);
    }
    var liveProfiles = {};
    liveProfiles[$scope.user.sys_id] = {
        userID: $scope.user.sys_id,
        name: $scope.user.name,
        initials: $window.NOW.user_initials
    };
    if ($window.NOW.user_avatar) {
        liveProfiles[$scope.user.sys_id].userImage = $window.NOW.user_avatar;
    }

    $scope.getLiveProfileByUserId = function(userId) {
        return liveProfiles[userId];
    };

    var pending = {};

    //Little caching implementation to make sure we only get a given user's profile once.
    $scope.hasLiveProfile = function hasLiveProfile(userId) {
        if (!userId)
            return false;

        if (liveProfiles[userId])
            return true;

        if (pending[userId])
            return false;

        pending[userId] = $http.get('/api/now/live/profiles/sys_user.' + userId).then(function(response) {
            liveProfiles[userId] = {
                userID: userId,
                name: response.data.result.name,
                initials: buildInitials(response.data.result.name),
                avatar: response.data.result.avatar
            };
        });
        return false;
    };

    function buildInitials(name) {
        if (!name)
            return "--";

        var initialMatchRegex = /^[A-ZÀ-Ÿ]|^[\u3040-\u309f]|^[\u30a0-\u30ff]|^[\uff66-\uff9f]|^[\u4e00-\u9faf]/;
        // Included Hiragana, Katakana, CJK Unified Ideographs and Halfwidth and Fullwidth Forms Blocks
        // Hiragana -> Japanese words, Katakana -> foreign words
        // CJK Unified Ideographs -> modern Chinese, Japanese, Korean and Vietnamese characters

        var initials = name.split(" ").map(function(word) {
            return word.toUpperCase();
        }).filter(function(word) {
            return word.match(initialMatchRegex);
        }).map(function(word) {
            return word.substring(0, 1);
        }).join("");

        return (initials.length > 3) ? initials.substr(0, 3) : initials;
    }


    function setupAttachmentHandler() {
        $scope.attachmentHandler = new nowAttachmentHandler(attachSuccess, appendError);

        function attachSuccess() {
            $rootScope.$broadcast("sp.attachments.update", $scope.data.sys_id);
        }

        function appendError(error) {
            spUtil.addErrorMessage(error.msg + error.fileName);
            $scope.errorMessages.push(error);
        }

        $timeout(function() {
            $scope.attachmentHandler.setParams($scope.data.table, $scope.data.sys_id, 1024 * 1024 * $scope.data.maxAttachmentSize);
        });
    }
    setupAttachmentHandler();

    var recordWatcherTimer;
    $scope.$on('record.updated', function(name, data) {
        // Use record watcher update if:
        //	This record was updated AND This widget didn't trigger the update.
        if (data.table_name == $scope.data.table && data.sys_id == $scope.data.sys_id) {
            $timeout.cancel(recordWatcherTimer);
            recordWatcherTimer = $timeout(function() {
                if (skipNextRecordWatchUpdate)
                    skipNextRecordWatchUpdate = false;
                else
                    spUtil.update($scope).then(function(r) {
                        $scope.data.stream = r.stream;
                    });
            }, 250);
        }
    });

    $scope.$on('sp.show_location_icon', function(evt) {
        $scope.data.showLocationIcon = true;
    });

    $scope.$on('sn.attachment.scanned', function() {
        if ($scope.data.sys_id != -1)
            updateAttachmentState($scope.data.table, $scope.data.sys_id);
    });

    $scope.$on('attachment.updated', function(evt, options) {
        if ($scope.data.sys_id != -1 && options.sys_id == $scope.data.sys_id)
            updateAttachmentState($scope.data.table, $scope.data.sys_id);
    });

    function updateAttachmentState(table, sys_id) {
        c.server.update().then(function(data) {
            if (!data.stream || !data.stream.entries)
                return;
            var newEntries = data.stream.entries;
            var currEntries = $scope.data.mergedEntries;
            var oldSize = currEntries ? currEntries.length : 0;
            var newSize = newEntries.length;
            for (var i = 0; i < oldSize; i++) {
                if (!currEntries[i].attachment)
                    continue;
                for (var j = 0; j < newSize; j++) {
                    if (currEntries[i].sys_id == newEntries[j].sys_id && newEntries[j].attachment) {
                        currEntries[i].attachment.state = newEntries[j].attachment.state;
                        break;
                    }
                }
            }
        });
    }

    $scope.scanAttachment = function(attachment) {
        snAttachmentHandler.scanAttachment(attachment);
    };

    var typingUsers = [];
    $rootScope.$on('sp.sessions', function(evt, sessions) {
        $scope.typing = [];
        var liveMessages = [];
        var tempTypingUsers = [];
        Object.keys(sessions).forEach(function(session) {
            var journalFields = scope.data.stream.journal_fields;
            var canUserReadJournalField = false;
            session = sessions[session];

            for (var j = 0; j < journalFields.length; j++) {
                if (journalFields[j].name === session.field_type) {
                    canUserReadJournalField = journalFields[j].can_read;
                    break;
                }
            }

            if (session.status === 'typing' && canUserReadJournalField) {
                $scope.typing.push(session);
                tempTypingUsers.push(session.user_display_name);

                if (typingUsers.indexOf(session.user_display_name) === -1)
                    liveMessages.push({ 'type': 'typing', 'user': session.user_display_name });
            } else
                return;

        });
        announce(liveMessages);
        typingUsers = tempTypingUsers;
    });

    $scope.$on('sp.conversation_title.changed', function(evt, text) {
        $scope.data.ticketTitle = text;
    });

    $scope.$watch("data.canWrite", function() {
        $rootScope.$broadcast("sp.record.can_write", $scope.data.canWrite);
    });

    var streamUpdateTimer;
    $scope.$watch("data.stream", function() {
        $timeout.cancel(streamUpdateTimer);
        streamUpdateTimer = $timeout(function() {
            mergeStreamEntries();
        }, 50);
    });

    function mergeStreamEntries() {
        // KLF ADDITION
        // Adding a sort so the messages display in the correct order
        // when messages are merged sometimes the order isn't maintained
        function sort(mergedEntries) {
            mergedEntries.sort((x, y) => x.sys_created_on_adjusted > y.sys_created_on_adjusted ? -1 :
                x.sys_created_on_adjusted < y.sys_created_on_adjusted ? 1 : 0);
        }
        // END KLF ADDITION

        $scope.placeholder = $scope.data.placeholderNoEntries;
        if (!$scope.data.stream || !$scope.data.stream.entries)
            return;

        $scope.placeholder = $scope.data.placeholder;
        var entries = $scope.data.stream.entries;
        for (var i = 0; i < entries.length; i++) {
            if (entries[i].attachment)
                entries[i].attachment = $scope.attachmentHandler.canViewImage([entries[i].attachment])[0];

        }
        if (!$scope.data.mergedEntries) {
            $scope.data.mergedEntries = $scope.data.stream.entries.slice();
            for (var j = 0; i < entries.length; i++) {
                if (entries[j].value)
                    entries[j].value = entries[i].value.replace(/\n/g, '<br/>');
                existingEntries[entries[j].sys_id] = true;
            }
            // KLF ADDITION
            sort(mergedEntries);
            // END KLF ADDITION

            return;
        }

        var mergedEntries = $scope.data.mergedEntries;
        var liveMessages = [];
        for (var k = entries.length - 1; i >= 0; i--) {
            var curEntry = entries[k];
            if (isNewEntry(mergedEntries, curEntry)) {
                if (curEntry.value) {
                    curEntry.value = curEntry.value.replace(/\n/g, '<br/>');
                    liveMessages.push({ 'type': 'comment', 'user': curEntry.name, 'comment': curEntry.value });
                }
                if (entries[k].attachment)
                    liveMessages.push({ 'type': 'attachment', 'user': curEntry.name });
                mergedEntries.unshift(curEntry);
                existingEntries[curEntry.sys_id] = true;
            }
        }

        // KLF ADDITION
        sort(mergedEntries);
        // END KLF ADDITION

        announce(liveMessages);
    }

    function announce(messages) {
        setTimeout(function() {
            var liveMessages = [];
            for (var i = 0, l = messages.length; i < l; i++) {
                var message = messages[i];
                switch (message.type) {
                    case 'attachment':
                        liveMessages.push({ 'message': i18n.format(i18n.getMessage('{0} has added a new attachment'), { '0': message.user }) });
                        break;
                    case 'comment':
                        liveMessages.push({ 'message': i18n.format(i18n.getMessage('{0} has entered an additional comment {1}'), { '0': message.user, '1': message.comment }) });
                        break;
                    case 'typing':
                        liveMessages.push({ 'message': i18n.format(i18n.getMessage('{0} is typing'), { '0': message.user }) });
                        break;
                }
            }
            if (liveMessages.length)
                spAriaUtil.sendLiveMessage(liveMessages);

        }, 50);
    }

    function isNewEntry(mergedEntries, item) {
        for (var i = 0; i < mergedEntries.length; i++) {
            if (mergedEntries[i].sys_id === item.sys_id) {
                return false;
            }
        }
        return true;
    }

    $scope.getPlaceholder = function() {
        if ($scope.data.use_dynamic_placeholder && $scope.data.useSecondaryJournalField)
            return $scope.data.secondaryJournalField.label;
        return $scope.placeholder;
    };

    var colorCache;
    $scope.getFieldColor = function(fieldName) {
        var defaultColor = "transparent";
        if (colorCache) {
            if (fieldName in colorCache)
                return colorCache[fieldName];
            else
                return defaultColor;
        }

        colorCache = {};
        var jf = $scope.data.stream.journal_fields;
        for (var i = 0; i < jf.length; i++) {
            colorCache[jf[i].name] = jf[i].color || defaultColor;
        }
        return $scope.getFieldColor(fieldName);
    };

    $scope.checkInLocation = function() {
        $rootScope.$broadcast("check_in_location");
        $rootScope.$broadcast("location.sharing.start");
    };

    $scope.$on("location.sharing.end", function() {
        $timeout(function() { $scope.msg = "";}, 500);
    });

    $scope.$on("location.sharing.start", function() {
        $scope.msg = $scope.data.sharingLocMsg;
        spAriaUtil.sendLiveMessage($scope.data.sharingLocMsg);
    });

    $scope.scanBarcode = function() {
        $rootScope.$broadcast("scan_barcode");
    };

    $scope.$on("attachment.upload.start", function() {
        $scope.data.isPosting = true;
        $scope.msg = $scope.data.uploadingAttachmentMsg;
        postLock = true;
        spAriaUtil.sendLiveMessage($scope.data.uploadingAttachmentMsg);
    });

    $scope.$on("attachment.upload.stop", function() {
        $scope.data.isPosting = false;
        $scope.msg = "";
        //update the stream so we get the new attachment
        if (!postLock)
            return;

        spUtil.update($scope).then(function(r) {
            $scope.data.stream = r.stream;
        });
    });

    $scope.trustAsHtml = function(text) {
        return $sce.trustAsHtml(text);
    };

    $scope.data.isPosting = false;

    $scope.postEntry = function(input) {
        post(input);
    };

    function post(input) {
        postLock = true;
        if ($scope.data.isPosting)
            return;

        if (!input)
            return;

        input = input.trim();
        $scope.data.journalEntry = input;

        if ($scope.data.useSecondaryJournalField)
            $scope.data.journalEntryField = $scope.data.secondaryJournalField.name;
        else
            $scope.data.journalEntryField = $scope.data.primaryJournalField.name;
        $scope.data.isPosting = true;
        if (postLock) {
            spUtil.update($scope).then(function() {
                $scope.data.isPosting = false;
                reset();
                spAriaUtil.sendLiveMessage($scope.data.messagePostedMsg);
                $timeout(function() {
                    $scope.setFocus(); // sets focus back on input, defined in "link"
                });
            }, function() {
                spUtil.addErrorMessage($scope.data.messagePostFailedMsg);
                $scope.data.isPosting = false;
            });
        }

        postLock = false;
        skipNextRecordWatchUpdate = true;
        $scope.setFocus(); // sets focus back on input, defined in "link"
    }

    $scope.sanitizeHtmlContent = function(content) {
        return $sce.trustAsHtml(spUtil.sanitizeHtml(content));
    };

    var reset = function() {
        $scope.userTyping("");
        $scope.data.journalEntry = "";
        $scope.updateFormWithJournalFields();
        $scope.data.useSecondaryJournalField = false;
        $scope.data.journalEntryField = "";
    };

    $scope.keyPress = function(event) {
        if ($scope.data.isPosting) {
            if (event.keyCode === 13 && !event.shiftKey)
                event.preventDefault();
            return;
        }

        if ($scope.data.enterKeyAddsNewLine)
            return; // must click Send button to submit

        if (event.keyCode === 13 && !event.shiftKey) {
            event.preventDefault();
            $timeout(function() {
                if ($scope.data.journalEntry)
                    $scope.postEntry($scope.data.journalEntry);
            }, 250);
        }
    };

    $scope.userTyping = function(input) {
        var status = "viewing";
        if (input.length)
            status = "typing";

        var field = $scope.data.useSecondaryJournalField ? $scope.data.secondaryJournalField.name : $scope.data.primaryJournalField.name;
        $scope.$emit("record.typing", { status: status, value: input, table: $scope.data.table, sys_id: $scope.data.sys_id, field_type: field });
        $scope.updateFormWithJournalFields();
    };
    $scope.updateFormWithJournalFields = function() {
        var fieldName, fieldToClear = "";
        if ($scope.data.useSecondaryJournalField) {
            fieldName = $scope.data.secondaryJournalField.name;
            fieldToClear = $scope.data.primaryJournalField.name;
        } else {
            fieldName = $scope.data.primaryJournalField.name;
            fieldToClear = "";
        }
        $scope.$emit("activity_stream_is_changed", { "fieldName": fieldName, "fieldToClear": fieldToClear, "input": $scope.data.journalEntry });
    };

    $scope.toggleTranslation = function(e) {
        e.showDetails = !e.showDetails;
        var translationObject = c.data.translation;
        e.toggleMsg = e.showDetails ? translationObject.hideMsg : translationObject.showMsg;
    };

    $scope.getTranslatedText = function(translations) {
        if (!(Array.isArray(translations)))
            return;
        var translatedText;
        var translationsLength = translations.length;
        for (var index = 0; index < translationsLength; index++) {
            if (translations[index].targetLanguage === g_lang) {
                translatedText = translations[index].translatedText;
                break;
            }
        }
        return translatedText;
    };

    $scope.getAdditionalParameters = function(e, isRetry) {
        return {
            'event': {
                'eventName': 'Activity Stream - Portal',
                'fieldType': e.element,
                'retry': isRetry
            },
            'additionalParameters': [{
                'parameterName': 'textType',
                'parameterValue': 'html'
            }, {
                'parameterName': 'escapeHtml',
                'parameterValue': e.contains_code
            }]
        };
    };

    $scope.showTranslationInProgress = function(e) {
        e.showTranslation = true;
        e.isTranslationInProgress = true;
        e.isTranslationSuccess = false;
        e.isTranslationError = false;
    };

    $scope.showTranslationSuccess = function(e, translatedText, credits) {
        e.translatedText = translatedText;
        e.credits = credits;
        e.toggleMsg = c.data.translation.hideMsg;
        e.isTranslationInProgress = false;
        e.isTranslationSuccess = true;
        e.isTranslationError = false;
        e.showDetails = true;
    };

    $scope.showTranslationError = function(e, errorMessage, tryAgain) {
        e.isTranslationInProgress = false;
        e.isTranslationSuccess = false;
        e.isTranslationError = true;
        e.translatedText = errorMessage;
        e.tryAgain = tryAgain;
    };

    $scope.translateText = function(e, isRetry) {
        $scope.showTranslationInProgress(e);
        var translationObject = c.data.translation;
        dynamicTranslation.getTranslation(e.value && e.value.replace(/<br ?\/?>/g, "\n"), $scope.getAdditionalParameters(e, isRetry)).then(
            function(successResponse) {
                var detectedLanguage = successResponse.detectedLanguage;
                if ((detectedLanguage) && (detectedLanguage.code === g_lang)) {
                    $scope.showTranslationError(e, translationObject.sameLanguageErrorMsg, false);
                    return;
                }
                var translatedText = $scope.getTranslatedText(successResponse.translations);
                if (translatedText) {
                    var credits = i18n.format(translationObject.creditsMsg, successResponse.translator);
                    $scope.showTranslationSuccess(e, translatedText, credits);
                } else {
                    translatedText = translationObject.genericErrorMsg;
                    $scope.showTranslationError(e, translatedText, true);
                }
            },
            function(errorResponse) {
                var errorCode = errorResponse.code;
                var errorMessage;
                var showRetry = false;
                switch (errorCode) {
                    case '40052':
                        errorMessage = translationObject.maxLengthErrorMsg;
                        break;
                    case '40055':
                        errorMessage = translationObject.credentialsErrorMsg;
                        break;
                    case '40053':
                    case '40054':
                    case '40056':
                        errorMessage = translationObject.langNotSupportedErrorMsg;
                        break;
                    default:
                        errorMessage = translationObject.genericErrorMsg;
                        showRetry = true;
                }
                $scope.showTranslationError(e, errorMessage, showRetry);
            }
        );
    };
    $scope.$on('sp.textOnlyZoom', function() {
        $window.autosize && $window.autosize.update($("#post-input"));
    });

    $scope.seeAllText = function(e) {
        $http.get('/api/now/ui/stream_entry/full_entry?sysparm_sys_id=' + e.sys_id).then(function(response) {
            if (response.data && response.data.result)
                e.value = response.data.result;
            e.is_truncated = false; // even if it didn't work, remove the anchor
        });
    };
}]]></client_script>
        <controller_as>c</controller_as>
        <css>$text-white: #fff !default;
$sp-space--xxs: 2px !default;
$sp-space--xs: 4px !default;
$sp-space--md: 12px !default;
$sp-space--3xl: 40px !default;

.panel-title {
  display: inline;
}

.panel-title-container {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.panel-title-icons {
	display: flex;
	align-items: center;
	padding: 0;
	margin: 0;
	span {
		padding: 0;
		margin: 0;

		.panel-button {
			display: flex;
			align-items: center;
			margin: 0 0 0 15px;
			line-height: initial;

			&amp;:hover, &amp;:focus {
				text-decoration: none;
			}
		}
	}
}

.timeline-heading, .timeline-body {
  padding-left: 2px;
}

.timeline-heading test {
  float:right;
}

.timeline-body &gt; p {
  white-space: normal;
  overflow-x: hidden;
}

.timeline-body ul &gt; li {
  float: none;
}

.no-resize {
  resize: none;
}

.journal-field-indicator {
  width: 5px;
  position: absolute;
  left: 5px;
  top: 5px;
  bottom: 5px;
  z-index: 3;
}

.panel-heading {
  word-wrap: break-word;
}

.avatar-container {
  cursor: default;
}

ul {
  list-style: none;
}

.overflow-hidden {
  overflow: hidden;
}


.timeline-badge-wrap {
  margin: auto;
  max-width: 115px;
  word-break: keep-all;
}

.timeline-badge.success {
  background-color: $success;
  height: 58px;
}

.timeline-badge {
  position: relative;
  left:25%;
  width:50%;
  border-radius:50%;
}

.timeline-badge span{
  position:absolute;
  top:50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size:13px;
  color: $text-white;
}

.timeline::before {
  content: none;
}

.timeline-before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 20px;
    left: 0;
    right: 50%;
    border-right: $sp-space--xxs $legend-border-color solid;
}

.journal-type {
 	display: inline-flex;
  display: -ms-inline-flexbox;
  flex-wrap: wrap;
  -webkit-justify-content: flex-end;
}

.fa-circle {
  font-size: $font-size-small/3;
  padding: 7px;
}

@media (max-width: 768px) {
  .timeline-badge-wrap {
    margin: 0;
  }
  .timeline-badge {
    left: 10%;
  }
  .timeline-before {
    left: $sp-space--3xl;
    right: inherit;
  }
}

@media print {
  .timeline-before {
    display: none;
  }
}

.translation-font {
  font-size: $font-size-base;
}

.translate-link {
  cursor: pointer;
  @extend .translation-font;
}

.translation-credits {
  font-style: italic;
}

.translation-message {
  padding-top: 10px;
  font-size: $font-size-base;
  white-space: pre-wrap;
  overflow-wrap: break-word;
}

.toggle-link-show {
  display: none;
}

.translation-credits {
  font-style: italic;
}

.translation-icon {
  width: $sp-space--md;
  height: $sp-space--md;
  padding-right: $sp-space--xs;
  @extend .translation-font;
}

.translation-container {
  border: 1px solid $well-border;
  border-radius: 3px;
  background-color: $well-bg;
  padding: 10px;
  color: $text-color;
  margin-top: 10px;
  margin-left: 2px;
  @extend .translation-font;
}

.translation-delimiter {
  padding: 7px;
  @extend .translation-font;
}

.translate-wrap {
  white-space: nowrap;
}

img {
  max-width:100%;
}

.dateformat-calendar {
  padding-right: $sp-space--xs;
}

/* KLF Additions */
/* sed to expand items on the timeline to fill the entire horizontal space */
.klf-expanded-items .timeline &gt; li &gt; .timeline-badge {
  left: 3rem;
}

.klf-expanded-items .timeline-badge-wrap {
  margin: 0px 3px;
  max-width: 115px;
}

.klf-expanded-items .timeline-badge {
  left:0;
}

.klf-expanded-items .timeline-before {
  left: 30px;
  right: auto;
}

.klf-expanded-items .timeline &gt; li &gt; .timeline-panel {
  width: calc(100% - 12rem);
  left: 8rem;
  float: left;
}

.snb-expanded-items .timeline &gt; li.timeline-inverted &gt; .timeline-panel {
  float: left;
}</css>
        <data_table>sp_instance</data_table>
        <demo_data>{"options": {
	"sys_id": -1,
		"table": "incident"
	}
}</demo_data>
        <description/>
        <docs/>
        <field_list/>
        <has_preview>false</has_preview>
        <id>klf-ticket-conversations</id>
        <internal>false</internal>
        <link><![CDATA[function link(scope, elm) {
	// Set the focus back on the input for IE11
	scope.setFocus = function() {
		var input = $(elm[0]).find('textarea#post-input');
		if (input[0])
			input[0].focus();
	};
}]]></link>
        <name>KLF Ticket Conversations</name>
        <option_schema>[{"hint":"Placeholder text shows selected journal field","name":"use_dynamic_placeholder","section":"Behavior","label":"Use dynamic placeholder","type":"boolean"},{"hint":"Message to show when record has no readable journal field","name":"no_readable_journal_field_message","default_value":"","section":"Presentation","label":"No readable journal field message","type":"string"},{"hint":"Enter key behavior is specified by system property (glide.service_portal.comment.enter_adds_newline) unless overridden here","name":"enter_key_behavior","section":"Behavior","default_value":"System property","label":"Enter key behavior","type":"choice","choices":[{"label":"System property","value":"System property"},{"label":"Submit","value":"Submit"},{"label":"New line","value":"New line"}]},{"hint":"Set to true to make the tiems on the timeline use all the horizontal space instead of using 50% of the space","name":"is_klf_expanded_items","section":"Presentation","default_value":"false","label":"Use Large Timeline Items","type":"boolean"}]</option_schema>
        <public>false</public>
        <roles>snc_external,snc_internal</roles>
        <script><![CDATA[(function() {
    // KLF ADDITION
    var klfSpUtils = new global.KLF_SPUtils();
    // END KLF ADDITION

    data.currentUserID = gs.getUserID();
    data.supportedAttachmentExtensions = gs.getProperty("glide.attachment.extensions", '');
    data.maxAttachmentSize = parseInt(gs.getProperty("com.glide.attachment.max_size", 1024));
    if (isNaN(data.maxAttachmentSize))
        data.maxAttachmentSize = 24;
    data.uploadingAttachmentMsg = gs.getMessage("Uploading attachment...");
    data.sharingLocMsg = gs.getMessage("Sharing location...");
    data.scanBarcodeMsg = gs.getMessage("Scan barcode");
    data.checkInLocMsg = gs.getMessage("Check in location");
    data.messagePostedMsg = gs.getMessage("Message has been sent");
    data.messagePostFailedMsg = gs.getMessage("Failed to post the message");
    data.viewMsg = gs.getMessage("View");
    data.attachAddedMsg = gs.getMessage("Attachment added");
    data.attachFailMsg = gs.getMessage("Failed to add attachment");
    data.scanFailedMsg = gs.getMessage("File failed security scan");
    data.sys_id = (input && input.sys_id) || options.sys_id || $sp.getParameter("sys_id");
    data.table = (input && input.table) || options.table || $sp.getParameter("table");
    data.is_new_order = (($sp.getParameter("is_new_order") + '') === "true");
    // don't use options.title unless sys_id and table also come from options
    if (options && options.sys_id && options.table)
        data.ticketTitle = options.title;
    data.placeholder = options.placeholder || gs.getMessage("Type your message here...");
    data.placeholderNoEntries = options.placeholderNoEntries || gs.getMessage("Type your message here...");
    data.btnLabel = options.btnLabel || gs.getMessage("Send");
    data.includeExtended = options.includeExtended || false;
    data.use_dynamic_placeholder = options.use_dynamic_placeholder;
    data.hideAttachmentBtn = options.hideAttachmentBtn;
    data.viewAttachmentMsg = gs.getMessage("View attachment");
    data.downloadAttachmentMsg = gs.getMessage("Download attachment");

    data.enterKeyAddsNewLine = false;
    if (options.enter_key_behavior == "System property")
        data.enterKeyAddsNewLine = gs.getProperty("glide.service_portal.comment.enter_adds_newline") == "true";
    else if (options.enter_key_behavior == "New line")
        data.enterKeyAddsNewLine = true;

    var gr = new GlideRecord(data.table);
    if (!gr.isValid())
        return;

    gr.get(data.sys_id);
    data.isNewRecord = data.sys_id == -1 || gr.isNewRecord();
    if ((!gr.isValidRecord() && data.sys_id != -1) || !gr.canRead())
        return;

    data.table = gr.getRecordClassName(); // use actual table for the record
    options.no_readable_journal_field_message = options.no_readable_journal_field_message || gs.getMessage("No readable comment field");
    data.number = gr.getDisplayValue('number');
    data.number = data.number ? data.number : '';
    data.numberCreatedMsg = gs.getMessage("{0} Created", data.number);
    data.created_on = gr.getValue('sys_created_on');
    data.created_on_adjusted = gr.getDisplayValue('sys_created_on');
    data.requestSubmitMsg = gs.getMessage("Thank You. Your request {0} has been submitted.", data.number);

    var translationLuaParameters = {
        'event': {
            'eventName': 'Activity Stream - Portal'
        },
        'tableName': data.table
    };
    var isDynamicTranslationInstalled = GlidePluginManager.isActive("com.glide.dynamic_translation");
    if (isDynamicTranslationInstalled) {
        var isDynamicTranslationEnabled = sn_dt_api.DynamicTranslation.isEnabled(translationLuaParameters);
        data.isTranslationEnabled = isDynamicTranslationEnabled && isDynamicTranslationEnabled.translation;
        if (data.isTranslationEnabled)
            initDynamicTranslation();
    }

    function initDynamicTranslation() {
        var translation = {};
        translation.translateLinkMsg = gs.getMessage("Translate");
        translation.sameLanguageErrorMsg = gs.getMessage("This content is written in your preferred language. No need to translate.");
        translation.genericErrorMsg = gs.getMessage("Unable to translate.");
        translation.credentialsErrorMsg = gs.getMessage("Credentials are missing or invalid. Contact your administrator.");
        translation.maxLengthErrorMsg = gs.getMessage("Text has exceeded the maximum length.");
        translation.langNotSupportedErrorMsg = gs.getMessage("Text cannot be translated to your preferred language.");
        translation.creditsMsg = gs.getMessage("Translated by {0}");
        translation.translationProgressMsg = gs.getMessage("Translating...");
        translation.hideMsg = gs.getMessage("Hide");
        translation.showMsg = gs.getMessage("Show");
        translation.tryAgainMsg = gs.getMessage("Try Again");
        data.translation = translation;
    }

    // KLF ADDITION
    data.primaryJournalFieldName = options.primaryJournalFieldName;
    // END KLF ADDITION

    if (input) { // if we have input then we're saving
        if (input.isPosting && input.journalEntry && input.journalEntryField) {
            if (gr.canWrite(input.journalEntryField)) {
                gr[input.journalEntryField].setDisplayValue(input.journalEntry);
                gr.update();
                $sp.logStat('Comments', data.table, data.sys_id, input.journalEntry);
            }
        }
        data.ticketTitle = input.ticketTitle;
        data.placeholder = input.placeholder;
        data.btnLabel = input.btnLabel;
        data.includeExtended = input.includeExtended;
        // KLF ADDITION
        data.primaryJournalFieldName = input.primaryJournalFieldName;
        data.displayTitle = input.displayTitle;
        // END KLF ADDITION
    } else {
        if (!data.ticketTitle) {
            if (gr.short_description.canRead())
                data.ticketTitle = gr.getDisplayValue("short_description");
            if (!data.ticketTitle)
                data.ticketTitle = data.number;
        }

        $sp.logStat('Task View', data.table, data.sys_id);
    }

    data.canWrite = gr.canWrite();
    data.canAttach = userCanAttach(gr);
    data.canRead = gr.canRead();
    data.hasWritableJournalField = false;
    data.hasReadableJournalField = false;
    if (data.canRead && !data.isNewRecord) {
        data.stream = $sp.getStream(data.table, data.sys_id);
        // Journal fields come in correct order already
        // so grab the first 2 writeable fields
        if ('journal_fields' in data.stream) {
            var jf = data.stream.journal_fields;
            for (var i = 0; i < jf.length; i++) {
                if (jf[i].can_read === true)
                    data.hasReadableJournalField = true;
                if (jf[i].can_write === true) {
                    // KLF ADDITION
                    // Adding ability to specify primary journal field name
                    data.hasWritableJournalField = true;
                    if (!data.primaryJournalField) {
                        var fieldName = jf[i].name;
                        if (data.primaryJournalFieldName) {
                            // The user has specified a primary field name so use that as primary
                            if (fieldName == data.primaryJournalFieldName) {
                                data.hasWritableJournalField = true;
                                data.primaryJournalField = jf[i];
                            } else {
                                data.primaryJournalField = jf[i];
                            }
                        } else {
                            data.hasWritableJournalField = true;
                            data.primaryJournalField = jf[i];
                        }
                    } else if (data.includeExtended && !data.secondaryJournalField) {
                        data.secondaryJournalField = jf[i];
                    } else {
                        break;
                    }
                }
            }
        }
    }

    // KLF ADDITION
    var klfEntries = [];
    if (data.sys_id != -1) {
        var history = klfSpUtils.getHistory(data.table, data.sys_id);
        klfEntries = klfSpUtils.getActivityEntries(history, data.table);
        data.stream.entries = /** @type {Activity[]} */ ([]).concat(data.stream.entries, klfEntries);
    }
    // END KLF ADDITION

    data.tableLabel = gr.getLabel();

    function userCanAttach(originalRecord) {
        if (!gs.hasRole(gs.getProperty("glide.attachment.role")))
            return false;

        // To check whether user can upload attachments, need to check "no_attachment" table
        // attribute of the target record (e.g., incident vs. task), so fetch it if we need to.
        // GlideRecordScriptUtil.getRealRecord is not available to scoped apps, so can't use it.
        var targetRecordForAttributes = originalRecord;
        if (originalRecord.getRecordClassName() != originalRecord.getTableName()) {
            targetRecordForAttributes = new GlideRecord(originalRecord.getRecordClassName());
            targetRecordForAttributes.get(originalRecord.getUniqueValue());
        }
        return targetRecordForAttributes.getAttribute("no_attachment") != "true";
    }

})();]]></script>
        <servicenow>false</servicenow>
        <sys_class_name>sp_widget</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-08-11 23:58:31</sys_created_on>
        <sys_id>4f50c194478c121058ceeb02d16d434d</sys_id>
        <sys_mod_count>10</sys_mod_count>
        <sys_name>KLF Ticket Conversations</sys_name>
        <sys_package display_value="KLF Global" source="fa03e59197682910b2e1f97e6253af92">fa03e59197682910b2e1f97e6253af92</sys_package>
        <sys_policy/>
        <sys_scope display_value="KLF Global">fa03e59197682910b2e1f97e6253af92</sys_scope>
        <sys_update_name>sp_widget_4f50c194478c121058ceeb02d16d434d</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2025-11-13 00:54:41</sys_updated_on>
        <template><![CDATA[<div ng-class="::{'klf-expanded-items':isKlfExpandedItmes}">
<div ng-if="!data.canRead && !data.isNewRecord">
    ${Requested record not found}
  </div>
<div ng-if="data.canRead && !data.isNewRecord" class="panel panel-{{options.color}} b ticket_conversation">
<div class="panel-heading">

<div class="h2 panel-title panel-title-container ticket-conversation-title">
<h4 class="h4 panel-title" ng-if="::embeddedInForm" aria-label="{{::data.ticketTitle}} ${Ticket history}">{{::data.ticketTitle}}</h4>
<h2 class="h4 panel-title" ng-if="::!embeddedInForm" aria-label="{{::data.ticketTitle}} ${Ticket history}">{{::data.ticketTitle}}</h2>

<div class="pull-right panel-title-icons">
<span>
<button type="button" ng-show="data.showLocationIcon && data.canWrite" class="panel-button btn btn-link" ng-click="checkInLocation()" data-original-title="{{data.checkInLocMsg}}" data-toggle="tooltip" data-container="section.page" data-placement="bottom">
<span class="glyphicon glyphicon-globe"></span>
</button>
</span>
<span>
<button type="button" class="panel-button btn btn-link" ng-show="isNative" ng-click="scanBarcode()" title="{{data.scanBarcodeMsg}}">
<span class="glyphicon glyphicon-barcode"></span>
</button>
</span>
<span ng-if="::(!data.hideAttachmentBtn)"><sp-attachment-button modal="true" supported-extensions="{{::data.supportedAttachmentExtensions}}" ng-if="::data.canWrite && data.canAttach"></sp-attachment-button></span>
</div>
</div>

</div>

<div class="panel-body">
<div ng-if="data.hasReadableJournalField">
<div ng-show="data.hasWritableJournalField" class="input-group">
<textarea ng-keypress="keyPress($event)" sn-resize-height="trim" rows="1" id="post-input" class="form-control no-resize overflow-hidden" ng-model='data.journalEntry' ng-model-options='{debounce: 250}' ng-attr-placeholder="{{getPlaceholder()}}" aria-label="{{getPlaceholder()}}" title="{{getPlaceholder()}}" data-toggle="tooltip" data-placement="top" autocomplete="off" ng-change="userTyping(data.journalEntry)"></textarea>
<span class="journal-field-indicator" ng-style="({'background-color': data.useSecondaryJournalField ? data.secondaryJournalField.color : data.primaryJournalField.color})"></span>
<span class="input-group-btn" style="vertical-align: top">
<input type="button" class="btn btn-primary" value="{{data.btnLabel}}" ng-disabled="data.isPosting" ng-click="postEntry(data.journalEntry)"/>
</span>
</div>
<div ng-if="::(data.secondaryJournalField && data.secondaryJournalField.can_write)">
<label class="pull-right">
<input type="checkbox" ng-model="::data.useSecondaryJournalField" ng-change="updateFormWithJournalFields()"/>
<span> {{::data.secondaryJournalField.label}}</span>
</label>
</div>
<ul class="list-group m-b-none" ng-if="typing.length > 0">
<li class="list-group-item user-typing m-t" ng-repeat="u in typing">${{{::u.user_display_name}} is typing}</li>
</ul>
<ul class="list-group m-b-none m-t" ng-if="msg">
<li class="list-group-item user-typing">{{msg}}</li>
</ul>
<div class="timeline-container">
<ul role="list" class="timeline" aria-label="${Ticket history}">
<div class="timeline-before" role="presentation" aria-hidden="true"></div>
<li class="timeline-item" ng-class="::{'timeline-inverted': (e.user_sys_id == data.currentUserID) || isKlfExpandedItmes}" ng-repeat="e in data.mergedEntries">
<div class="timeline-badge">
<sn-avatar-once ng-if="hasLiveProfile(e.user_sys_id)" primary="getLiveProfileByUserId(e.user_sys_id)" class="avatar-large" show-presence="false" enable-context-menu="false">
</sn-avatar-once>
</div>
<div class="timeline-panel">
<div class="timeline-panel-inner" ng-style="::{'border-color': getFieldColor(e.element)}">
<div class="timeline-heading">
<div class="timeline-title h4">{{::e.name}}</div>
<p class = "time-text">
<small class="text-muted">
<span ng-if="showDate" class="dateformat-calendar">{{::e.sys_created_on_adjusted}}</span>
<span ng-if="showTimeAgo">
<span class="glyphicon glyphicon-time" aria-hidden="true" tabindex="-1"></span>
<sn-time-ago timestamp="::e.sys_created_on"></sn-time-ago>
</span>
</small>
<i ng-if="::e.field_label" class="fa fa-circle text-muted" aria-hidden="true"></i>
<small class = "text-muted journal-type">{{::e.field_label}}</small>
<span ng-if= "::((e.element == 'comments' || e.element == 'work_notes') && data.isTranslationEnabled)">
<small class="text-muted translation-delimiter">•</small>
<span class="translate-wrap">
<i class="text-muted translation-icon icon-translation"></i>
<a class="translate-link" href="javascript:void(0)" ng-click="translateText(e, false)">{{::data.translation.translateLinkMsg}}</a>
</span>
</span>
</p>
</div>
<div class="timeline-body">
<div ng-if="::(e.element != 'attachment')">
  <p ng-if="!e.is_truncated" ng-bind-html="::sanitizeHtmlContent(e.value)"></p>
  <p ng-if="e.is_truncated" ng-bind-html="sanitizeHtmlContent(e.value)"></p>
  <a ng-if="e.is_truncated" href="javascript:void(0)" role="button" aria-label="${Click here to see all text}" ng-click="seeAllText(e)">${See all text}</a>
</div>

<div ng-if="::(e.element == 'attachment')">
<a ng-if="e.attachment.viewImage && e.attachment.thumbnail_path && e.attachment.state === 'available'"
        target="_blank" href="/sys_attachment.do?view=true&sys_id={{::e.attachment.sys_id}}"
        aria-label="{{data.viewAttachmentMsg}} {{e.attachment.file_name}}"
        style="display:block">
            <img alt="" ng-src="/{{::e.attachment.path}}?t=medium" class="img-responsive"/>
    </a>
    <img ng-if="(!e.attachment.viewImage || e.attachment.state !== 'available') && e.attachment.thumbnail_path"
        alt="" ng-src="/{{::e.attachment.path}}?t=medium" class="img-responsive"/>
<div>
<div ng-if="(e.attachment.state == 'available')">
<a href="/sys_attachment.do?sys_id={{::e.attachment.sys_id}}" target="_blank" title="{{dataViewMsg}}"><strong>{{e.attachment.file_name}}</strong></a><br/>
                        {{::e.attachment.size}}
                      </div>
<div ng-if="(e.attachment.state == 'not_available')">
<span title="{{dataViewMsg}}" class="not_available">{{e.attachment.file_name}}</span><br/>
<span class="error">{{::data.scanFailedMsg}}</span>
</div>
<div ng-if="(e.attachment.state == '' || e.attachment.state == 'pending' || e.attachment.state == 'available_conditionally')">
<a href="javascript:void(0)" ng-click="scanAttachment(e.attachment)" title="{{dataViewMsg}}"><strong>{{e.attachment.file_name}}</strong></a><br/>
                        {{::e.attachment.size}}
                      </div>
</div>
</div>
</div>
<div ng-if="e.showTranslation" class="translation-container">
<div ng-if="e.isTranslationInProgress">
<i class="translation-icon icon-translation"></i>
<span aria-live="polite">{{::data.translation.translationProgressMsg}}</span>
</div>
<div ng-if="e.isTranslationSuccess">
<i class="translation-icon icon-translation"></i>
<a class="translate-link" href="javascript:void(0)" ng-click="toggleTranslation(e)">{{e.toggleMsg}}</a>
<span class="translation-delimiter">•</span>
<span class="translation-credits">{{e.credits}}</span>
<p ng-if="e.showDetails" class="translation-message" ng-bind-html="::sanitizeHtmlContent(e.translatedText)"></p>
</div>
<div ng-if="e.isTranslationError">
<i class="translation-icon icon-translation"></i>
{{e.translatedText}}
<a ng-if="e.tryAgain" href="javascript:void(0)" class="translate-link" ng-click="translateText(e, true)">{{::data.translation.tryAgainMsg}}</a>
</div>
</div>
</div>
</div>
</li>
<li role="listitem" class="timeline-item" ng-class="::{'timeline-inverted': (data.stream.user_sys_id == data.currentUserID) || isKlfExpandedItems}" aria-label="{{data.stream.user_full_name}}">
<div class="timeline-badge">
<sn-avatar-once ng-if="hasLiveProfile(data.stream.user_sys_id)" primary="getLiveProfileByUserId(data.stream.user_sys_id)" class="avatar-large" show-presence="false" enable-context-menu="false">
</sn-avatar-once>
</div>
<div class="timeline-panel timeline-panel-first-item">
<div class="timeline-heading">
<div class="timeline-title h4">{{data.stream.user_full_name}}</div>
<p>
<small class="text-muted">
<span ng-if="showDate" class="dateformat-calendar">{{data.created_on_adjusted}}</span>
<span ng-if="showTimeAgo">
<span class="glyphicon glyphicon-time" aria-hidden="true" tabindex="-1"></span>
<sn-time-ago timestamp="data.created_on"></sn-time-ago>
</span>
</small>
</p>
</div>
<div class="timeline-body">
<p>{{data.numberCreatedMsg}}</p>
</div>
</div>
</li>
<li>
<div class="timeline-badge-wrap">
<div class="timeline-badge success">
<span>${Start}</span>
</div>
</div>
</li>
</ul>
</div>

</div>
<div ng-if="!data.hasReadableJournalField">
        {{options.no_readable_journal_field_message}}
      </div>
</div>
</div>
</div>]]></template>
    </sp_widget>
    <sys_es_latest_script action="INSERT_OR_UPDATE">
        <id>4f50c194478c121058ceeb02d16d434d</id>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-08-12 00:15:30</sys_created_on>
        <sys_id>3f3409d8478c121058ceeb02d16d43f3</sys_id>
        <sys_mod_count>0</sys_mod_count>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-08-12 00:15:30</sys_updated_on>
        <table>sp_widget</table>
        <use_es_latest>false</use_es_latest>
    </sys_es_latest_script>
</record_update>
