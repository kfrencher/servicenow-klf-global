<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>package_private</access>
        <active>true</active>
        <api_name>global.KLF_RecordSync</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>KLF_RecordSync</name>
        <script><![CDATA[//@ts-ignore
var global = global || {};

/**
 * Configuration object for the KLF_RecordSync class
 * @typedef KLF_RecordSyncConnectionConfig
 * @property {string} instanceUrl
 * @property {string} username
 * @property {string} password
 */

/**
 * Object that provides methods to sync records between two ServiceNow instances
 * The primary method is {@link global.KLF_RecordSync.syncTable} which syncs data from one 
 * table in a ServiceNow instance to the same table in a different ServiceNow instance
 * @class KLF_RecordSync
 * @param {KLF_RecordSyncConnectionConfig} connectionConfig
 */
global.KLF_RecordSync = function(connectionConfig) {
    this.connectionConfig = connectionConfig;
};

/**
 * Imports a record into ServiceNow using GlideUpdateManager2
 * @param {string} xml
 */
global.KLF_RecordSync.loadRecordByGlideUpdateManager2 = function(xml) {
    var updateManager = new global.GlideUpdateManager2();
    updateManager.loadXML(xml);
};

global.KLF_RecordSync.prototype = {

    /**
     * Syncs data from one table in a ServiceNow instance to the same table in a different ServiceNow instance 
     * @param {string} tableName
     */
    syncTable: function(tableName) {
        var chunkSize = 10;
        // I want to transfer the data in chunks. So I will use the GlideRecord.setWindow method to query a batch of records at a time.
        // Use the tableName to query a batch of records from the source table
        var source = new GlideRecord(tableName);
        source.chooseWindow(0, chunkSize);
        source.query();

        var sourceSysIds = [];
        while (source.next()) {
            sourceSysIds.push(source.sys_id.toString());
        }

        // Query the remote instance using the REST table API for the records that are in the sysIds array
        var request = this.createRestMessage();
        request.setHttpMethod('GET');
        var endpointPath = '/api/now/table/' + tableName
        var query = [
            'sysparm_fields=sys_id',
            'sysparm_query=sys_idIN' + encodeURIComponent(sourceSysIds.join(','))
        ].join('&');
        var endpoint = request.getEndpoint() + endpointPath + '?' + query;
        request.setEndpoint(endpoint);
        var response = request.execute();
        gs.log(response.getBody());

        if (response.getStatusCode() != 200) {
            gs.error('Failed to get the records from the target instance');
            gs.error('Received status code: ' + response.getStatusCode());
            gs.error('Received body: ' + response.getBody());
            return null;
        }

        // The sys_ids in the response represent records that already exist in the target instance
        // Subtract the sys_ids in the response from the sysIds array to get the sys_ids that do not exist in the target instance
        // This will be the sys_ids that need to be inserted into the target instance
        var targetSysIds = [];
        var responseBody = JSON.parse(response.getBody());
        responseBody.result.forEach(function(record) {
            targetSysIds.push(record.sys_id);
        });
        var sysIdsToInsert = sourceSysIds.filter(function(sysId) {
            return targetSysIds.indexOf(sysId) === -1;
        });

        gs.log('sysIdsToInsert: ' + sysIdsToInsert);
        gs.info(tableName + ' Syncing ' + sysIdsToInsert.length + ' records: ');

        // Requery the source for the records that need to be inserted into the target instance
        var sourceToInsert = new GlideRecord(tableName);
        sourceToInsert.addQuery('sys_id', 'IN', sysIdsToInsert.join(','));
        sourceToInsert.query();
        var unloadDocument = this.createUnloadDocument();
        while (sourceToInsert.next()) {
            // recordSync.documentToString(recordSync.unloadRecord(incident));
            this.documentToString(this.unloadRecord(sourceToInsert, unloadDocument));
        }

        this.loadRecordByTableApi(tableName, this.documentToString(unloadDocument));

        gs.info(this.documentToString(unloadDocument));
    },

    /**
     * Returns a sn_ws.RESTMessageV2 object that is configured to make a request to the target instance
     * @returns {sn_ws.RESTMessageV2}
     */
    createRestMessage: function() {
        var request = new sn_ws.RESTMessageV2();
        request.setRequestHeader("Accept", "application/json");
        request.setBasicAuth(this.connectionConfig.username, this.connectionConfig.password);
        request.setEndpoint(this.connectionConfig.instanceUrl);
        return request;
    },


    /**
     * Copies the GlideRecord from the source ServiceNow instance to the target ServiceNow instance
     * using ServiceNow's Table API.
     */
    copyRecord: function(tableName, sysId) {
        // Get the XML payload of the source record
        var request = this.createRestMessage();
        request.setHttpMethod('GET');
        var instanceUrl = request.getEndpoint();
        var path = '/' + tableName + '_list.do?XML';
        var query = 'sysparm_query=' + encodeURIComponent('sys_id=' + sysId);
        var endpoint = instanceUrl + path + '&' + query;
        gs.info('Using endpoint: ' + endpoint);
        request.setEndpoint(endpoint);

        var response = request.execute();
        if (response.getStatusCode() != 200) {
            gs.error('Failed to get the record from the source instance');
            gs.error('Received status code: ' + response.getStatusCode());
            gs.error('Received body: ' + response.getBody());
            return null;
        }

        var payload = response.getBody();
        gs.info(payload);
    },

    /**
     * Creates a document object that can be passed to {@link global.KLF_RecordSync.unloadRecord}
     * This is useful when you want to add multiple unloaded records to the same document
     * @returns {Document}
     */
    createUnloadDocument: function() {
        var document = global.GlideXMLUtil.newDocument('unload');
        var date = new GlideDateTime();
        document.documentElement.setAttribute('unload_date', date.toString());
        return document;
    },

    /**
     * Generates XML from GlideRecord that is like the XML generated by exporting a record from ServiceNow.
     * This XML can be used to import a record into ServiceNow.
     * @param {GlideRecord} glideRecord 
     * @param {Document} [document]
     * @returns {Document}
     */
    unloadRecord: function(glideRecord, document) {
        var _document = document || global.GlideXMLUtil.newDocument('unload');
        var date = new GlideDateTime();
        _document.documentElement.setAttribute('unload_date', date.toString());
        new global.GlideUnloader().unloadGlideRecord(_document, glideRecord, 'INSERT_OR_UPDATE');
        return _document;
    },

    /**
     * Returns the XML representation of the Document
     * @param {Document} document 
     * @returns {string}
     */
    documentToString: function(document) {
        return global.GlideXMLUtil.toString(document);
    },

    /**
     * Generates XML from GlideRecord that is like the XML generated by exporting a record from ServiceNow.
     * This XML can be used to import a record into ServiceNow.
     * @param {GlideRecord} glideRecord 
     */
    unloadRecordCustom: function(glideRecord) {
        var xml = '<record_update>';
        xml += '<' + glideRecord.getTableName() + '>';
        var fields = glideRecord.getFields();
        for (var i = 0; i < fields.size(); i++) {
            var field = fields.get(i);
            xml += '<' + field + '>' + glideRecord[field] + '</' + field + '>';
        }
        xml += '</' + glideRecord.getTableName() + '>';
        xml += '</record_update>';
        return xml;
    },

    /**
     * Imports a record into ServiceNow using the Table API.
     * @param {String} tableName 
     * @param {String} xml 
     */
    loadRecordByTableApi: function(tableName, xml) {
        var request = this.createRestMessage();
        request.setHttpMethod('POST');
        var instanceUrl = request.getEndpoint();
        var path = '/' + tableName + '_list.do';
        var endpoint = instanceUrl + path;
        gs.info('Using endpoint: ' + endpoint);
        request.setEndpoint(endpoint);
        request.setRequestBody(xml);

        var response = request.execute();
        if (response.getStatusCode() != 200) {
            gs.error('Failed to load the record into the target instance');
            gs.error('Received status code: ' + response.getStatusCode());
            gs.error('Received body: ' + response.getBody());
            return null;
        }

        var payload = response.getBody();
        gs.info(payload);

        return payload;
    }


};


// new global.KLF_RecordSync().copyRecord('x_53417_demo_cat_breed', '8cf4884f9779311024d7b066f053af8c');
// var recordSync = new global.KLF_RecordSync({
//     username: 'admin',
//     password: 'Pip33jord!',
//     // instanceUrl: 'https://dev144209.service-now.com'
//     instanceUrl: 'https://dev188047.service-now.com'
// })

// recordSync.syncTable('x_53417_demo_cat_breed');
// var incident = new GlideRecord('incident');
// incident.query();
// incident.next();
// gs.info(recordSync.documentToString(recordSync.unloadRecord(incident)));]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-03-15 13:15:46</sys_created_on>
        <sys_id>d358538c9701021024d7b066f053af34</sys_id>
        <sys_mod_count>37</sys_mod_count>
        <sys_name>KLF_RecordSync</sys_name>
        <sys_package display_value="G KLF" source="fa03e59197682910b2e1f97e6253af92">fa03e59197682910b2e1f97e6253af92</sys_package>
        <sys_policy/>
        <sys_scope display_value="G KLF">fa03e59197682910b2e1f97e6253af92</sys_scope>
        <sys_update_name>sys_script_include_d358538c9701021024d7b066f053af34</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-04-12 23:49:23</sys_updated_on>
    </sys_script_include>
</record_update>
