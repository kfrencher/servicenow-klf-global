<?xml version="1.0" encoding="UTF-8"?><record_update table="sys_script_include">
    <sys_script_include action="INSERT_OR_UPDATE">
        <access>public</access>
        <active>true</active>
        <api_name>global.KLF_RecordSync</api_name>
        <caller_access/>
        <client_callable>false</client_callable>
        <description/>
        <name>KLF_RecordSync</name>
        <script><![CDATA[//@ts-ignore
var global = global || {};

/**
 * Configuration object for the KLF_RecordSync class
 * @typedef KLF_RecordSyncConnectionConfig
 * @property {string} instanceUrl
 * @property {string} username
 * @property {string} password
 * @property {number} [chunkSize=220] Optional. The number of records to sync at a time. Default is 220. 220 was chosen
 * intentionally because there is a limitation on some ServiceNow instances that will throw a 400 error if the URL is too long
 */

/**
 * TODO: 
 * - Modify syncTable to properly support extended tables because when exporting an extended table record attachments are not properly handled
 * - Possibly add ability to do incremental syncs where the mod count or sys_updated_on is used to determine if a record needs to be synced
 * - Also may need a way to properly handle sys_user and sys_user_group references that aren't the same in the target instance or don't exist
 * - Probably need better error handling. It's non-existent right now
 * 
 * Object that provides methods to sync records between two ServiceNow instances
 * 
 * NOTE: To use any of the sync methods you must install this application on the target
 * instance. This scoped application contains the REST API that is used to import records into
 * the target instance
 * 
 * The primary method is {@link global.KLF_RecordSync.syncAllDataInScope} which syncs all the data in
 * a scoped application from one ServiceNow instance to the same application in a different ServiceNow instance
 * 
 * Other methods allow you to sync a single table or a single record
 * {@link global.KLF_RecordSync.syncTable} and {@link global.KLF_RecordSync.syncRecord} respectively
 * 
 * @class KLF_RecordSync
 * @param {KLF_RecordSyncConnectionConfig} connectionConfig
 * @example
 * var recordSync = new global.KLF_RecordSync({
 *     username: 'admin',
 *     password: gs.getProperty('KLF_RecordSync.user.password'), // Retrieve password from encoded password property
 *     instanceUrl: 'https://dev188047.service-now.com',
 *     chunkSize: 220
 * });
 * 
 * // Example of syncing all the data in a scope
 * recordSync.syncAllDataInScope('x_53417_demo');
 * 
 * // Example of including approvals that are associated with the scope
 * // This shows that you can also sync data that is outside of the scope as sysapproval_approver records
 * // are in the global scope
 * var demoApproval = new GlideRecord('sysapproval_approver');
 * demoApproval.addQuery('source_table', 'STARTSWITH', 'x_53417_demo');
 * recordSync.syncTable('sysapproval_approver', demoApproval.getEncodedQuery());
 */
global.KLF_RecordSync = function(connectionConfig) {
    this.connectionConfig = connectionConfig;
};

/**
 * The manifest is an object that represents the data that is being transfered in a transaction. The keys
 * in the manifest are the table name and the values are an object where the keys are the sys_ids of the records
 * being transferred. It's a bit unconventional, but the reason the sys_ids are stored as keys in an object is because
 * i want them to be unique.
 * {
 *    "incident": {"sys_id1": true, "sys_id2": true},
 * }
 * @typedef {{[tableName:string]: {[sysId:string]: boolean}}} KLFManifest
 */
global.KLF_RecordSync.Manifest = function() {
    /** @type {KLFManifest} */
    this.manifest = {};
};

global.KLF_RecordSync.Manifest.prototype = {
    /**
     * Adds a record to the manifest
     * @param {string} tableName 
     * @param {string} sysId 
     */
    addRecord: function(tableName, sysId) {
        if (!this.manifest[tableName]) {
            this.manifest[tableName] = {};
        }
        this.manifest[tableName][sysId] = true;
    },

    /**
     * Adds multiple records to the manifest
     * @param {string} tableName
     * @param {string[]} sysIds
     */
    addRecords: function(tableName, sysIds) {
        sysIds.forEach(function(sysId) {
            JSON.stringify("manifest: " + this.manifest);
            this.addRecord(tableName, sysId);
        }, this);
    },

    /**
     * Adds a record to the manifest by GlideRecord
     * @param {GlideRecord} glideRecord 
     */
    addRecordByGlideRecord: function(glideRecord) {
        this.addRecord(glideRecord.getTableName(), glideRecord.getUniqueValue());
    },

    /**
     * Adds a manifest to the current manifest
     * @param {global.KLF_RecordSync.Manifest} manifest
     */
    addManifest: function(manifest) {
        manifest.getTables().forEach(function(tableName) {
            manifest.getSysIdsForTable(tableName).forEach(function(sysId) {
                this.addRecord(tableName, sysId);
            }, this);
        }, this);
    },

    /**
     * Returns all the tables in the manifest
     * @returns {string[]}
     */
    getTables: function() {
        return Object.keys(this.manifest).sort();
    },

    /**
     * Returns all the sys_ids for a table in the manifest
     */
    getSysIdsForTable: function(tableName) {
        return Object.keys(this.manifest[tableName]).sort();
    },

    /**
     * Returns a Object representation of the manifest. This is to facilitate JSON serialization
     */
    toObj: function() {
        var manifest = {};
        this.getTables().forEach(function(tableName) {
            manifest[tableName] = this.getSysIdsForTable(tableName);
        }, this);
        return manifest;
    },

    /**
     * Returns a JSON representation of the manifest
     */
    toJson: function() {
        return JSON.stringify(this.toObj(), null, 4);
    },

    /**
     * Validates the manifest against the local instance. It checks to see if the records exist in the local instance.
     * It then builds a new manifest of records that do not exist in the local instance
     * @returns {global.KLF_RecordSync.Manifest} A manifest of records that do not exist in the local instance
     */
    validate: function() {
        var missingManifest = new global.KLF_RecordSync.Manifest();
        this.getTables().forEach(function(tableName) {
            var manifestSysIds = this.getSysIdsForTable(tableName);
            var gr = new GlideAggregate(tableName);
            gr.addQuery('sys_id', 'IN', manifestSysIds.join(','));
            gr.groupBy('sys_id');
            gr.query();
            var foundSysIds = [];
            while (gr.next()) {
                foundSysIds.push(gr.getValue('sys_id'));
            }
            var missingSysIds = new global.ArrayUtil().diff(manifestSysIds, foundSysIds);
            missingManifest.addRecords(tableName, missingSysIds);
        }, this);
        return missingManifest;
    }
};

/**
 * Creates a manifest from the JSON representation
 * @param {string} jsonManifest
 * @returns {global.KLF_RecordSync.Manifest}
 */
global.KLF_RecordSync.Manifest.createManifestFromJson = function(jsonManifest) {
    var manifest = new global.KLF_RecordSync.Manifest();
    var parsed = JSON.parse(jsonManifest);
    for (var tableName in parsed) {
        manifest.addRecords(tableName, parsed[tableName]);
    }
    return manifest;
}


/**
 * Imports a record into ServiceNow using GlideUpdateManager2
 * @param {string} xml
 */
global.KLF_RecordSync.loadRecordByGlideUpdateManager2 = function(xml) {
    var updateManager = new global.GlideUpdateManager2();
    updateManager.loadXML(xml);
};

global.KLF_RecordSync.prototype = {

    dataTransferUtils: new global.KLF_DataTransferUtils(),

    /**
     * Syncs all the data in the scope excluding any tables listed in the excluded table
     * list
     * @param {string} scopeNamespace
     * @param {string[]} [excludedTables]
     */
    syncAllDataInScope: function(scopeNamespace, excludedTables) {
        var tables = this.dataTransferUtils.getBaseTablesInScope(scopeNamespace, excludedTables);
        var me = this;
        tables.forEach(function(table) {
            me.syncTable(table);
        });
    },

    /**
     * Syncs document that could contain data from a number of tables from ServiceNow instance to target ServiceNow instance 
     * @param {Document} document
     * @returns {string?}
     */
    syncDocument: function(document) {
        return this.sendToRemoteInstance(this.documentToString(document));
    },

    /**
     * Syncs a single record from one table in a ServiceNow instance to the same table in a different ServiceNow instance 
     * @param {GlideRecord} glideRecord
     * @returns {string?}
     */
    syncRecord: function(glideRecord) {
        var unloadDocument = this.createUnloadDocument();
        var unloadedData = this.unloadRecordWithRelatedRecords(glideRecord, unloadDocument);
        gs.info('Manifest: ' + unloadedData.manifest.toJson());
        return this.sendToRemoteInstance(this.documentToString(unloadDocument));
    },

    /**
     * Syncs data from one table in a ServiceNow instance to the same table in a different ServiceNow instance 
     * You can provide an encoded query string to filter the records that are synced
     * 
     * One simple way to get the encoded query string is to use the filter navigator in ServiceNow
     * Another is to build the query using GlideRecord and then call GlideRecord.getEncodedQuery()
     * @param {string} tableName
     * @param {string} [encodedQueryString]
     */
    syncTable: function(tableName, encodedQueryString) {
        var me = this;

        function syncChunk(start, chunkSize) {
            // I want to transfer the data in chunks. So I will use the GlideRecord.setWindow method to query a batch of records at a time.
            // Use the tableName to query a batch of records from the source table
            var source = new GlideRecord(tableName);
            source.orderBy('sys_created_on');
            source.chooseWindow(start, start + chunkSize);
            if (encodedQueryString) {
                source.addEncodedQuery(encodedQueryString);
            }
            source.query();

            var sourceSysIds = [];
            while (source.next()) {
                sourceSysIds.push(source.sys_id.toString());
            }

            // Query the remote instance using the REST table API for the records that are in the sysIds array
            var request = me.createRestMessage();
            request.setHttpMethod('GET');
            var endpointPath = '/api/now/table/' + tableName
            var query = [
                'sysparm_fields=sys_id',
                'sysparm_query=sys_idIN' + encodeURIComponent(sourceSysIds.join(','))
            ].join('&');
            var endpoint = request.getEndpoint() + endpointPath + '?' + query;
            request.setEndpoint(endpoint);
            var response = request.execute();

            if (response.getStatusCode() != 200) {
                gs.error('Failed to get the records from the target instance');
                gs.error('Received status code: ' + response.getStatusCode());
                gs.error('Received body: ' + response.getBody());
                return null;
            }

            // The sys_ids in the response represent records that already exist in the target instance
            // Subtract the sys_ids in the response from the sysIds array to get the sys_ids that do not exist in the target instance
            // This will be the sys_ids that need to be inserted into the target instance
            var targetSysIds = [];
            var responseBody = JSON.parse(response.getBody());
            responseBody.result.forEach(function(record) {
                targetSysIds.push(record.sys_id);
            });
            var sysIdsToInsert = sourceSysIds.filter(function(sysId) {
                return targetSysIds.indexOf(sysId) === -1;
            });

            gs.info(tableName + ' Syncing ' + sysIdsToInsert.length + ' records: ');

            // Requery the source for the records that need to be inserted into the target instance
            var sourceToInsert = new GlideRecord(tableName);
            sourceToInsert.addQuery('sys_id', 'IN', sysIdsToInsert.join(','));
            sourceToInsert.query();
            var unloadDocument = me.createUnloadDocument();
            var manifest = new global.KLF_RecordSync.Manifest();
            while (sourceToInsert.next()) {
                var unloadedData = me.unloadRecordWithRelatedRecords(sourceToInsert, unloadDocument);
                manifest.addManifest(unloadedData.manifest);
            }

            if (sysIdsToInsert.length > 0) {
                me.sendToRemoteInstance(me.documentToString(unloadDocument));
                gs.info('Manifest for this chunk: ' + manifest.toJson());
            } else {
                gs.info('No records to sync for this chunk');
            }

        }

        var chunkSize = this.connectionConfig.chunkSize || 220;
        var glideRecord = new GlideRecord(tableName);
        if (glideRecord.isValid()) {
            gs.info('Starting sync of table: ' + tableName);
            // First get the size of the table
            // Then sync records in chunks
            if (encodedQueryString) {
                gs.info(encodedQueryString);
                glideRecord.addEncodedQuery(encodedQueryString);
            }
            glideRecord.query();
            var totalRecords = glideRecord.getRowCount();
            gs.info('Total records: ' + totalRecords);
            var i = 0;
            while (i < totalRecords) {
                syncChunk(i, chunkSize);
                i = i + chunkSize;
            }
        } else {
            throw new Error('Invalid table name: ' + tableName);
        }
    },

    /**
     * Returns a sn_ws.RESTMessageV2 object that is configured to make a request to the target instance
     * @returns {sn_ws.RESTMessageV2}
     */
    createRestMessage: function() {
        var request = new sn_ws.RESTMessageV2();
        request.setRequestHeader("Accept", "application/json");
        var authHeader = 'Basic ' + GlideStringUtil.base64Encode(this.connectionConfig.username + ':' + this.connectionConfig.password);
        request.setRequestHeader('Authorization', authHeader);
        // Do not use setBasicAuth. This does not work with mutual auth for some reason
        // request.setBasicAuth(this.connectionConfig.username, this.connectionConfig.password);
        request.setEndpoint(this.connectionConfig.instanceUrl);
        return request;
    },

    /**
     * Creates a document object that can be passed to {@link global.KLF_RecordSync.unloadRecord}
     * This is useful when you want to add multiple unloaded records to the same document
     * @returns {Document}
     */
    createUnloadDocument: function() {
        var document = global.GlideXMLUtil.newDocument('unload');
        var date = new GlideDateTime();
        document.documentElement.setAttribute('unload_date', date.toString());
        return document;
    },

    /**
     * Adds the record's related journal entries to the update set
     * @param {GlideRecord} parent
     * @param {Document} document
     * @returns {global.KLF_RecordSync.Manifest}
     */
    addJournalEntries: function(parent, document) {
        var manifest = new global.KLF_RecordSync.Manifest();

        var journal = new GlideRecord("sys_journal_field");
        // Intentionally using GlideRecord.getRecordClassName because it will correctly
        // handle returning the correct table name when dealing with extended records
        journal.addQuery("name", parent.getRecordClassName());
        journal.addQuery("element_id", parent.getUniqueValue());
        journal.query();
        while (journal.next()) {
            manifest.addRecordByGlideRecord(journal);
            this.unloadRecord(journal, document);
        }
        return manifest;
    },

    /**
     * Adds the record's related audit entries to the update set
     * @param {GlideRecord} parent
     * @param {Document} document
     * @returns {global.KLF_RecordSync.Manifest}
     */
    addAuditEntries: function(parent, document) {
        var manifest = new global.KLF_RecordSync.Manifest();

        var audit = new GlideRecord("sys_audit");
        // Intentionally using GlideRecord.getRecordClassName because it will correctly
        // handle returning the correct table name when dealing with extended records
        audit.addQuery("tablename", parent.getRecordClassName());
        audit.addQuery("documentkey", parent.getUniqueValue());
        audit.query();
        while (audit.next()) {
            manifest.addRecordByGlideRecord(audit);
            this.unloadRecord(audit, document);
        }
        return manifest;
    },

    /**
     * Adds the record's related currency entries to the update set
     * @param {GlideRecord} parent
     * @param {Document} document
     * @returns {global.KLF_RecordSync.Manifest}
     */
    addCurrencyEntries: function(parent, document) {
        var manifest = new global.KLF_RecordSync.Manifest();

        var currency = new GlideRecord("fx_currency_instance");
        // Intentionally using GlideRecord.getRecordClassName because it will correctly
        // handle returning the correct table name when dealing with extended records
        currency.addQuery("table", parent.getRecordClassName());
        currency.addQuery("id", parent.getUniqueValue());
        currency.query();
        while (currency.next()) {
            manifest.addRecordByGlideRecord(currency);
            this.unloadRecord(currency, document);
        }
        return manifest;
    },

    /**
     * Adds the record's related currency entries to the update set
     * @param {GlideRecord} parent
     * @param {Document} document
     * @returns {global.KLF_RecordSync.Manifest}
     */
    addPriceEntries: function(parent, document) {
        var manifest = new global.KLF_RecordSync.Manifest();

        var price = new GlideRecord("fx_price");
        // Intentionally using GlideRecord.getRecordClassName because it will correctly
        // handle returning the correct table name when dealing with extended records
        price.addQuery("table", parent.getRecordClassName());
        price.addQuery("id", parent.getUniqueValue());
        price.query();
        while (price.next()) {
            manifest.addRecordByGlideRecord(price);
            this.unloadRecord(price, document);
        }
        return manifest;
    },

    /**
     * Generates XML from GlideRecord that is like the XML generated by exporting a record from ServiceNow.
     * This XML can be used to import a record into ServiceNow.
     * @param {GlideRecord} glideRecord 
     * @param {Document} [document]
     * @returns {Document}
     */
    unloadRecord: function(glideRecord, document) {
        var _document = document || global.GlideXMLUtil.newDocument('unload');
        if (!document) {
            // If the document was not passed in, then add the unload_date attribute
            var date = new GlideDateTime();
            _document.documentElement.setAttribute('unload_date', date.toString());
        }

        // If this is an extended table then I need the true record and not the base record
        // If I detect this isn't the extended record I query for the extended record
        if (glideRecord.getTableName() != glideRecord.getRecordClassName()) {
            var extended = new GlideRecord(glideRecord.getRecordClassName());
            extended.get(glideRecord.getUniqueValue());
            new global.GlideUnloader().unloadGlideRecord(_document, extended, 'INSERT_OR_UPDATE');
        } else {
            new global.GlideUnloader().unloadGlideRecord(_document, glideRecord, 'INSERT_OR_UPDATE');
        }

        return _document;
    },

    /**
     * Generates XML from GlideRecord that is like the XML generated by exporting a record from ServiceNow.
     * This XML can be used to import a record into ServiceNow.
     * 
     * Adds the record and its related audit entries, journal entries, and attachments to the document
     * @param {GlideRecord} glideRecord 
     * @param {Document} [document]
     * @returns {{manifest:global.KLF_RecordSync.Manifest, document:Document}}
     */
    unloadRecordWithRelatedRecords: function(glideRecord, document) {
        var manifest = new global.KLF_RecordSync.Manifest();
        manifest.addRecordByGlideRecord(glideRecord);

        var _document = document || global.GlideXMLUtil.newDocument('unload');
        if (!document) {
            // If the document was not passed in, then add the unload_date attribute
            var date = new GlideDateTime();
            _document.documentElement.setAttribute('unload_date', date.toString());
        }

        // Initially add the record to the document
        this.unloadRecord(glideRecord, _document);

        // Add related records to the document
        manifest.addManifest(this.addAuditEntries(glideRecord, _document));
        manifest.addManifest(this.addJournalEntries(glideRecord, _document));
        manifest.addManifest(this.addCurrencyEntries(glideRecord, _document));
        manifest.addManifest(this.addPriceEntries(glideRecord, _document));

        return {
            manifest: manifest,
            document: _document
        };
    },

    /**
     * Merges two KLFManifest objects together. It merges the keys and the values of the two objects.
     * The resulting objects will have the keys of both objects and the values will be the unique values
     * of both objects based on the key.
     * @param {KLFManifest} manifest1
     * @param {KLFManifest} manifest2
     * @returns {KLFManifest}
     */
    mergeManifests: function(manifest1, manifest2) {
        for (var tableName in manifest2) {
            if (!manifest1[tableName]) {
                manifest1[tableName] = {};
            }
            for (var sysId in manifest2[tableName]) {
                manifest1[tableName][sysId] = true;
            }
        }
        return manifest1;
    },

    /**
     * Returns the XML representation of the Document
     * @param {Document} document 
     * @returns {string}
     */
    documentToString: function(document) {
        return global.GlideXMLUtil.toString(document);
    },

    /**
     * This isn't used right now. The thought is that it could be used to generate a custom version of the XML. You'd do
     * that if you needed to do something special with the XML before sending it to the target instance. One use case I can
     * think of is altering how the sys_user and sys_user_group references are handled because the sys_id values will be different
     * in the target instance
     * 
     * Generates XML from GlideRecord that is like the XML generated by exporting a record from ServiceNow.
     * This XML can be used to import a record into ServiceNow.
     * @param {GlideRecord} glideRecord 
     */
    unloadRecordCustom: function(glideRecord) {
        var xml = '<record_update>';
        xml += '<' + glideRecord.getTableName() + '>';
        var fields = glideRecord.getFields();
        for (var i = 0; i < fields.size(); i++) {
            var field = fields.get(i);
            xml += '<' + field + '>' + glideRecord[field] + '</' + field + '>';
        }
        xml += '</' + glideRecord.getTableName() + '>';
        xml += '</record_update>';
        return xml;
    },

    /**
     * Imports a record into ServiceNow using the Table API.
     * Returns whatever the response was or null if there was an error
     * @param {string} xml 
     * @returns {string?}
     */
    sendToRemoteInstance: function(xml) {
        var request = this.createRestMessage();
        request.setHttpMethod('POST');
        request.setRequestHeader('Content-Type', 'application/xml');
        var endpoint = request.getEndpoint() + gs.getProperty('KLF_RecordSync.endpoint.import.path');
        request.setEndpoint(endpoint);
        request.setRequestBody(xml);
        var response = request.execute();
        if (response.getStatusCode() != 200) {
            gs.error('Failed to load the record into the target instance');
            gs.error('Received status code: ' + response.getStatusCode());
            gs.error('Received body: ' + response.getBody());
            return null;
        }

        var payload = response.getBody();
        return payload;
    },

    /**
     * Checks the target instance for the list of records specified in the manifest. If the records do not exist in the target instance
     * then a new manifest is created that contains the records that do not exist in the target instance
     * @param {global.KLF_RecordSync.Manifest} manifest
     * @returns {global.KLF_RecordSync.Manifest?} A manifest of records that do not exist in the remote instance
     */
    validateSync: function(manifest) {
        var request = this.createRestMessage();
        request.setHttpMethod('POST');
        request.setRequestHeader('Content-Type', 'application/json');
        var endpoint = request.getEndpoint() + gs.getProperty('KLF_RecordSync.endpoint.import.path') + '/validate_manifest';
        request.setEndpoint(endpoint);
        request.setRequestBody(manifest.toJson());
        var response = request.execute();
        if (response.getStatusCode() != 200) {
            gs.error('Failed to validate manifest');
            gs.error('Received status code: ' + response.getStatusCode());
            gs.error('Received body: ' + response.getBody());
            return null;
        }

        var payload = response.getBody();
        var missingManifest = global.KLF_RecordSync.Manifest.createManifestFromJson(payload);
        return missingManifest;
    }

};]]></script>
        <sys_class_name>sys_script_include</sys_class_name>
        <sys_created_by>admin</sys_created_by>
        <sys_created_on>2024-03-15 13:15:46</sys_created_on>
        <sys_id>d358538c9701021024d7b066f053af34</sys_id>
        <sys_mod_count>124</sys_mod_count>
        <sys_name>KLF_RecordSync</sys_name>
        <sys_package display_value="G KLF" source="fa03e59197682910b2e1f97e6253af92">fa03e59197682910b2e1f97e6253af92</sys_package>
        <sys_policy/>
        <sys_scope display_value="G KLF">fa03e59197682910b2e1f97e6253af92</sys_scope>
        <sys_update_name>sys_script_include_d358538c9701021024d7b066f053af34</sys_update_name>
        <sys_updated_by>admin</sys_updated_by>
        <sys_updated_on>2024-05-27 12:27:13</sys_updated_on>
    </sys_script_include>
</record_update>
